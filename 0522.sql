--그룹화 함수
--부서 번호 별로 평균 급여 값 출력
--부서 번호 확인
SELECT DISTINCT DEPTNO FROM EMP;
--각 부서 번호에서 근무하는 직원 출력
SELECT * FROM EMP WHERE DEPTNO = 10;
SELECT * FROM EMP WHERE DEPTNO = 20;
SELECT * FROM EMP WHERE DEPTNO = 30;
--각 부서 번호에서 근무하는 직원들의 평균 급여 출력
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 10;
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 20;
SELECT AVG(SAL) FROM EMP WHERE DEPTNO = 30;
--집합연산자 UNION / UNION ALL 사용하여 함께 출력
SELECT '10' AS DEPTNO, AVG(SAL) FROM EMP WHERE DEPTNO = 10
UNION
SELECT '20' AS DEPTNO, AVG(SAL) FROM EMP WHERE DEPTNO = 20
UNION
SELECT '30' AS DEPTNO, AVG(SAL) FROM EMP WHERE DEPTNO = 30;
--GROUP BY 절을 이용하여 재현
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO;
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO;
SELECT DEPTNO, AVG(SAL) FROM EMP GROUP BY DEPTNO ORDER BY DEPTNO ASC;
--2개의 열을 이용하여 GROUP BY
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB;
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO ASC, JOB ASC;
--GROUP BY 에 사용하는 열 이름을 SELECT 절에서도 동일하게 사용
--GROUP BY 에 사용하지 않는 열 이름을 SELECT 절에서 사용하게 되면 오류 발생
SELECT DEPTNO, ENAME, AVG(SAL) FROM EMP GROUP BY DEPTNO;
--GROUP BY ~ HAVING (조건)
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO ASC, JOB ASC;
--평균 급여 2000 이상 => 전체 사원 14명을 가지고 그룹화
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP 
    GROUP BY DEPTNO, JOB 
    HAVING AVG(SAL) >= 2000
    ORDER BY DEPTNO ASC, JOB ASC;
--직책이 CLERK 인 경우 출력
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP 
    GROUP BY DEPTNO, JOB 
    HAVING JOB = 'CLERK'
    ORDER BY DEPTNO ASC, JOB ASC;
--WHERE 절과 비교  => 사원 6명을 가지고 그룹화
SELECT DEPTNO, JOB FROM EMP WHERE SAL >= 2000;
SELECT DEPTNO, JOB, AVG(SAL) FROM EMP WHERE SAL >= 2000
    GROUP BY DEPTNO, JOB 
    HAVING AVG(SAL) >= 2000
    ORDER BY DEPTNO ASC, JOB ASC;
--그룹화와 관련된 함수 = GROUP BY 와 함께 사용하는 함수
--먼저 GROUP BY 로 결과 출력
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY DEPTNO, JOB
    ORDER BY DEPTNO ASC, JOB ASC;
--ROLLUP: 열의 개수 + 1 개의 결과 출력
--1) A + B = 부서번호 + 직책 으로 GROUP BY
--2) A = 부서번호 로 GROUP BY
--3) 전체
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY ROLLUP(DEPTNO, JOB);
--CUBE: 2의 열의 개수 제곱 개의 결과 출력
--1) A + B = 부서번호 + 직책 으로 GROUP BY
--2) A = 부서번호 로 GROUP BY
--3) B = 직책 으로 GROUP BY
--4) 전체
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY CUBE(DEPTNO, JOB);
--ROLLUP 을 일부 열만 가지고 사용
--1) A + B = 부서번호 + 직책 으로 GROUP BY
--2) A = 부서번호 로 GROUP BY
--전체는 나오지 않음
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY DEPTNO, ROLLUP(JOB);
--1) A + B = 부서번호 + 직책 으로 GROUP BY
--2) A = 직책 으로 GROUP BY
--전체는 나오지 않음
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY JOB, ROLLUP(DEPTNO);
--GROUPING SETS
--1) A = 부서번호 로 GROUP BY
--2) B = 직책 으로 GROUP BY
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY GROUPING SETS(DEPTNO, JOB);
--GROUPING
--1) A + B = 부서번호 + 직책 으로 GROUP BY => 0 0
--2) A = 부서번호 로 GROUP BY => 0 1
--3) B = 직책 으로 GROUP BY => 1 0
--4) 전체 => 1 1
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL), 
       GROUPING(DEPTNO), GROUPING(JOB) 
    FROM EMP
    GROUP BY CUBE(DEPTNO, JOB);
--GROUPING_ID
--1) A + B = 부서번호 + 직책 으로 GROUP BY => 0 0 => 0
--2) A = 부서번호 로 GROUP BY => 0 1 => 1
--3) B = 직책 으로 GROUP BY => 1 0 => 2
--4) 전체 => 1 1 => 3
SELECT DEPTNO, JOB, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL), 
       GROUPING(DEPTNO), GROUPING(JOB), GROUPING_ID(DEPTNO, JOB)
    FROM EMP
    GROUP BY CUBE(DEPTNO, JOB);
--DECODE 문으로 비어있는 값을 채워보자
--비어있는 값 = 그룹화에 사용되지 않음 = GROUPING 함수 결과 1
SELECT DECODE(GROUPING(DEPTNO), 1, 'ALL_DEPT', DEPTNO) AS DEPTNO, 
       DECODE(GROUPING(JOB), 1, 'ALL_JOB', JOB) AS JOB, 
       COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL) FROM EMP
    GROUP BY CUBE(DEPTNO, JOB);
--LISTAGG
SELECT ENAME FROM EMP;
SELECT DEPTNO, ENAME FROM EMP GROUP BY DEPTNO, ENAME ORDER BY DEPTNO ASC, ENAME ASC;
--부서 별로 사원 이름을 알파벳 순서대로 나열한 다음 이름과 이름 사이에 ', ' 로 연결시켜 출력 
SELECT DEPTNO, 
       LISTAGG(ENAME, ', ') WITHIN GROUP(ORDER BY ENAME ASC) AS ENAME
       FROM EMP GROUP BY DEPTNO;
--부서 별로 사원 이름을 급여가 높은 순서대로 나열한 다음 이름과 이름 사이에 ', ' 로 연결시켜 출력 
SELECT DEPTNO, 
       LISTAGG(ENAME, ', ') WITHIN GROUP(ORDER BY SAL DESC) AS ENAME
       FROM EMP GROUP BY DEPTNO;
--PIVOT: 행을 열로 바꿈
SELECT DEPTNO, JOB, MAX(SAL) FROM EMP GROUP BY DEPTNO, JOB ORDER BY DEPTNO ASC, JOB ASC;
--부서번호를 행에서 열로 바꿈
SELECT * FROM (SELECT DEPTNO, JOB, SAL FROM EMP)
    PIVOT(MAX(SAL) FOR DEPTNO IN (10, 20, 30))
    ORDER BY JOB;
--직책을 행에서 열로 바꿈
SELECT * FROM (SELECT DEPTNO, JOB, SAL FROM EMP)
    PIVOT(MAX(SAL) FOR JOB IN ('ANALYST' AS ANALYST, 
                               'CLERK' AS CLERK, 
                               'MANAGER' AS MANAGER, 
                               'PRESIDENT' AS PRESIDENT, 
                               'SALESMAN' AS SALESMAN))
    ORDER BY DEPTNO;
--DECODE 문으로 PIVOT 테이블 만들어 보자
--직책을 행에서 열로 바꿈
SELECT DEPTNO, 
       MAX(DECODE(JOB, 'ANALYST', SAL)) AS ANALYST, 
       MAX(DECODE(JOB, 'CLERK', SAL)) AS CLERK, 
       MAX(DECODE(JOB, 'MANAGER', SAL)) AS MANAGER, 
       MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS PRESIDENT, 
       MAX(DECODE(JOB, 'SALESMAN', SAL)) AS SALESMAN
    FROM EMP
    GROUP BY DEPTNO
    ORDER BY DEPTNO;
--UNPIVOT
--PIVOT 테이블을 다시 UNPIVOT
SELECT * FROM(SELECT DEPTNO, 
       MAX(DECODE(JOB, 'ANALYST', SAL)) AS ANALYST, 
       MAX(DECODE(JOB, 'CLERK', SAL)) AS CLERK, 
       MAX(DECODE(JOB, 'MANAGER', SAL)) AS MANAGER, 
       MAX(DECODE(JOB, 'PRESIDENT', SAL)) AS PRESIDENT, 
       MAX(DECODE(JOB, 'SALESMAN', SAL)) AS SALESMAN
    FROM EMP
    GROUP BY DEPTNO
    ORDER BY DEPTNO)
    UNPIVOT (SAL FOR JOB IN (ANALYST, CLERK, MANAGER, PRESIDENT, SALESMAN))
    ORDER BY DEPTNO, JOB;
--
--조인: 여러 테이블을 하나의 테이블처럼 사용하는 방법
--행 14개
SELECT * FROM EMP;
--행 4개
SELECT * FROM DEPT;
--교차 조인 = 크로스 조인 = 모든 행의 조합 = 14 * 4 = 56
--조인 조건이 없어서 생긴 문제
SELECT * FROM EMP, DEPT;
SELECT * FROM EMP, DEPT ORDER BY EMP.EMPNO ASC, EMP.ENAME ASC, DEPT.DEPTNO ASC;
--등가조인 = 내부조인 = 단순조인
--같다는 조건으로 조인
SELECT * FROM EMP, DEPT WHERE EMP.DEPTNO = DEPT.DEPTNO;
--테이블 별칭 사용
SELECT * FROM EMP A, DEPT B WHERE A.DEPTNO = B.DEPTNO;
--열 이름을 구체화하여 작성할 것!
--테이블 이름 명시
SELECT * FROM EMP;
SELECT * FROM DEPT;
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, A.HIREDATE, A.SAL, A.COMM,
       B.DEPTNO, B.DNAME, B.LOC
    FROM EMP A, DEPT B WHERE A.DEPTNO = B.DEPTNO;
--테이블이 가지고 있는 열이 명확할 때는 문제 없음
SELECT ENAME, DNAME FROM EMP A, DEPT B WHERE A.DEPTNO = B.DEPTNO;
--공통되는 열에서는 오류 발생 => 반드시 테이블 출처 명시
SELECT ENAME, B.DEPTNO, DNAME FROM EMP A, DEPT B WHERE A.DEPTNO = B.DEPTNO;
--조건 추가
--조인에는 최소 테이블 개수 - 1 개 만큼의 조건이 필요함
--조인을 할 때 사용하고 있는 테이블 2개 => 조건이 하나가 필요함
--조인을 할 때 사용하고 있는 테이블 3개 => 조건이 두 개가 필요함
--예) A, B, C => A + B = 조건 1개 필요, A + B + C => 조건 1개 필요 
SELECT * FROM EMP A, DEPT B 
    WHERE A.DEPTNO = B.DEPTNO
      AND A.SAL >= 3000;
--비등가조인 = 등가조인 이외의 방식
--BETWEEN A AND B 문장으로 조인
SELECT * FROM EMP;
SELECT * FROM SALGRADE;
--조인
SELECT * FROM EMP A, SALGRADE B WHERE A.SAL BETWEEN B.LOSAL AND B.HISAL;
--자체 조인 = 같은 테이블 끼리 하는 조인
SELECT * FROM EMP;
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A, EMP B WHERE A.MGR = B.EMPNO;
--외부조인
--기준이 되는 테이블의 행은 모두 다 나와야 함 & 기준이 되지 않는 테이블은 교집합만 붙음
--LEFT OUTER JOIN
--왼쪽에 있는 테이블이 기준
--조건절에서 오른쪽에 있는 테이블 이름.열이름 뒤에 (+)
--직속상관 + 직속상관이 없는 사람도 나옴
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A, EMP B WHERE A.MGR = B.EMPNO (+);
--RIGHT OUTER JOIN
--오른쪽에 있는 테이블이 기준
--조건절에서 왼쪽에 있는 테이블 이름.열이름 뒤에 (+)
--부하직원 + 부하직원이 없는 사람도 나옴
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A, EMP B WHERE A.MGR (+) = B.EMPNO;
--SQL-99문법으로 조인
--등가조인과 결과는 같음
--1) NATURAL JOIN
-- 같다는 조건 X & 공통된 열 이름의 테이블 이름 X
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, A.HIREDATE, A.SAL, A.COMM,
       DEPTNO, B.DNAME, B.LOC
    FROM EMP A NATURAL JOIN DEPT B;
--2) JOIN USING
-- 같다는 조건 => USING 공통된 열 명시 & 공통된 열 이름의 테이블 이름 X
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, A.HIREDATE, A.SAL, A.COMM,
       DEPTNO, B.DNAME, B.LOC
    FROM EMP A JOIN DEPT B USING (DEPTNO);
--3) JOIN ON
-- 같다는 조건 O & 공통된 열 이름의 테이블 이름 O => 우리가 배운 문법과 제일 유사
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, A.HIREDATE, A.SAL, A.COMM,
       B.DEPTNO, B.DNAME, B.LOC
    FROM EMP A JOIN DEPT B ON (A.DEPTNO = B.DEPTNO);
--외부조인
--LEFT OUTER JOIN ON
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A LEFT OUTER JOIN EMP B ON (A.MGR = B.EMPNO);
--RIGHT OUTER JOIN ON
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A RIGHT OUTER JOIN EMP B ON (A.MGR = B.EMPNO);
--FULL OUTER JOIN ON
SELECT A.EMPNO, A.ENAME, A.MGR AS MGR_EMPNO, B.ENAME AS MGR_ENAME 
    FROM EMP A FULL OUTER JOIN EMP B ON (A.MGR = B.EMPNO);
--
--서브쿼리
--WHERE 절 뒤에서 사용하는 서브퀴리
--단일행 서브쿼리 = 결과가 하나 = 행이 1개
SELECT SAL FROM EMP WHERE ENAME = 'JONES';
SELECT * FROM EMP WHERE SAL > 2975;
SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');
--날짜 데이터와 함께 사용
SELECT * FROM EMP WHERE ENAME = 'SCOTT';
SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT';
--SCOTT 보다 일찍 입사한 직원 = SCOTT 입사일보다 과거 날짜 = 작은 값
SELECT * FROM EMP WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT');
--SCOTT 보다 늦게 입사한 직원 = SCOTT 입사일보다 미래 날짜 = 큰 값
SELECT * FROM EMP WHERE HIREDATE > (SELECT HIREDATE FROM EMP WHERE ENAME = 'SCOTT');
--다중행 함수와 함께 사용 = 결과가 하나
--전체 직원들의 평균 급여
SELECT AVG(SAL) FROM EMP;
--전체 직원들의 평균 급여보다 많이 받는 직원
SELECT * FROM EMP WHERE SAL > (SELECT AVG(SAL) FROM EMP);
--다중행 서브쿼리
SELECT DISTINCT DEPTNO FROM EMP;
--IN 연산자 = 같다는 OR 조건 여러 개 = 합집합
SELECT * FROM EMP WHERE DEPTNO IN (10,20,30);
SELECT * FROM EMP WHERE DEPTNO IN (SELECT DISTINCT DEPTNO FROM EMP);
--ANY / SOME = 여러 결과 중에 하나라도 만족하면 TRUE
-- = 조건 => 같다는 OR 조건 여러 개 = 합집합
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;
SELECT * FROM EMP WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
SELECT * FROM EMP WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);
--작다는 (<) 조건 = OR 조건 여러 개
--800 < 1100 < 2975 < 3000
--최대값보다 작은 급여 가진 직원
SELECT SAL FROM EMP WHERE DEPTNO = 20;
SELECT * FROM EMP WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 20);
SELECT * FROM EMP WHERE SAL < SOME (SELECT SAL FROM EMP WHERE DEPTNO = 20);
--단일행 서브쿼리로 재현 = 결과 동일
SELECT * FROM EMP WHERE SAL < (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 20);
--크다는 (>) 조건 = OR 조건 여러 개
--최소값보다 큰 급여 가진 직원
SELECT * FROM EMP WHERE SAL > ANY (SELECT SAL FROM EMP WHERE DEPTNO = 20);
SELECT * FROM EMP WHERE SAL > SOME (SELECT SAL FROM EMP WHERE DEPTNO = 20);
--단일행 서브쿼리로 재현 = 결과 동일
SELECT * FROM EMP WHERE SAL > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 20);
--ALL = 여러 결과 중에서 모두 만족해야 TRUE
-- = 조건 => 같다는 AND 조건 여러 개 이므로 사용 불가, 예) 한 사람이 하나의 급여를 가지고 있음
--부서별로 최대 급여 3개 값이 한 사람의 급여와 모두 같다는 조건을 성립할 수 없음
--작다는 (<) 조건 = AND 조건 여러 개
--950 < 1250 < 1500 < 1600 < 2850
--최소값보다 작은 급여 가진 직원
SELECT SAL FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP WHERE SAL < ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);
--단일행 서브쿼리로 재현 = 결과 동일
SELECT * FROM EMP WHERE SAL < (SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 30);
--크다는 (>) 조건 = AND 조건 여러 개
--최대값보다 큰 급여 가진 직원
SELECT * FROM EMP WHERE SAL > ALL (SELECT SAL FROM EMP WHERE DEPTNO = 30);
--단일행 서브쿼리로 재현 = 결과 동일
SELECT * FROM EMP WHERE SAL > (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = 30);
--